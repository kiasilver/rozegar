import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { jwtVerify } from 'jose';
import { prisma } from '@/lib/core/prisma';
import * as os from 'os';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function verifyJWT(token: string) {
  try {
    const secret = new TextEncoder().encode(process.env.JWT_SECRET!);
    const { payload } = await jwtVerify(token, secret);
    return payload as { userId: number; role: string };
  } catch {
    throw new Error("Invalid or expired token");
  }
}

// ???????? global ???? ????? ????????? ???? CPU
let previousCpuTimes: os.CpuInfo[] | null = null;
let previousTimestamp: number | null = null;

// ???? ???? ?????? ??????? CPU
function getCPUUsage(): { usage: number; cores: number; model: string } {
  const cpus = os.cpus();
  const cores = cpus.length;
  const model = cpus[0]?.model || 'Unknown';
  
  const currentTimestamp = Date.now();
  let usage = 0;
  
  // ??? ????? ???? ???? ????? CPU usage ?? ?????? ???????
  if (previousCpuTimes && previousTimestamp) {
    let totalIdle = 0;
    let totalTick = 0;
    let prevTotalIdle = 0;
    let prevTotalTick = 0;
    
    cpus.forEach((cpu, index) => {
      const times = cpu.times;
      totalIdle += times.idle;
      totalTick += times.user + times.nice + times.sys + times.idle + times.irq;
      
      if (previousCpuTimes && previousCpuTimes[index]) {
        const prevTimes = previousCpuTimes[index].times;
        prevTotalIdle += prevTimes.idle;
        prevTotalTick += prevTimes.user + prevTimes.nice + prevTimes.sys + prevTimes.idle + prevTimes.irq;
      }
    });
    
    const idle = totalIdle - prevTotalIdle;
    const total = totalTick - prevTotalTick;
    
    if (total > 0) {
      usage = Math.min(100, Math.max(0, ((total - idle) / total) * 100));
    }
  }
  
  // ??? loadavg ?? ????? ??? ? ????? ???? ?? ?? ??????? ???????
  const loadAvg = os.loadavg();
  if (loadAvg[0] > 0 && process.platform !== 'win32') {
    usage = Math.min(100, (loadAvg[0] / cores) * 100);
  }
  
  // ??? ???? 0 ??? ? ?? Windows ?????? ?? wmic ??????? ???????
  if (usage === 0 && process.platform === 'win32') {
    // ?? Windows? loadavg ??????? [0, 0, 0] ???????????
    // ?? ?? ????? ?????? ?? ???? times ??????? ???????
    let totalIdle = 0;
    let totalTick = 0;
    
    cpus.forEach((cpu) => {
      const times = cpu.times;
      totalIdle += times.idle;
      totalTick += times.user + times.nice + times.sys + times.idle + times.irq;
    });
    
    // ?????? ???? ??????? ?? ???? ???? idle
    if (totalTick > 0) {
      const idlePercent = (totalIdle / totalTick) * 100;
      usage = Math.max(1, Math.min(100, 100 - idlePercent));
    } else {
      // ??? totalTick 0 ???? ?? ????? ??????? ????????????
      usage = 5; // 5% ??????? ???? ?????
    }
  }
  
  // ????? ????? ???? ???? ??????? ?? ???? ???
  previousCpuTimes = JSON.parse(JSON.stringify(cpus)); // Deep copy
  previousTimestamp = currentTimestamp;
  
  return {
    usage: Math.round(usage * 100) / 100,
    cores,
    model
  };
}

// ???? ???? ?????? ??????? RAM
function getRAMUsage(): { total: number; used: number; free: number; usage: number } {
  const total = os.totalmem();
  const free = os.freemem();
  const used = total - free;
  const usage = (used / total) * 100;
  
  return {
    total: Math.round(total / (1024 * 1024 * 1024) * 100) / 100, // GB
    used: Math.round(used / (1024 * 1024 * 1024) * 100) / 100, // GB
    free: Math.round(free / (1024 * 1024 * 1024) * 100) / 100, // GB
    usage: Math.round(usage * 100) / 100
  };
}

// ???? ???? ?????? ??????? Hard Disk
async function getDiskUsage(): Promise<{ total: number; used: number; free: number; usage: number }> {
  try {
    // ???? Windows - ??????? ?? wmic
    if (process.platform === 'win32') {
      try {
        const { stdout } = await execAsync('wmic logicaldisk where "DeviceID=\'C:\'" get Size,FreeSpace /format:list');
        const lines = stdout.split('\n');
        let freeBytes = 0;
        let totalBytes = 0;
        
        for (const line of lines) {
          if (line.startsWith('FreeSpace=')) {
            freeBytes = parseInt(line.split('=')[1]?.trim() || '0', 10);
          } else if (line.startsWith('Size=')) {
            totalBytes = parseInt(line.split('=')[1]?.trim() || '0', 10);
          }
        }
        
        if (totalBytes > 0) {
          const total = totalBytes / (1024 * 1024 * 1024);
          const free = freeBytes / (1024 * 1024 * 1024);
          const used = total - free;
          const usage = (used / total) * 100;
          
          return {
            total: Math.round(total * 100) / 100,
            used: Math.round(used * 100) / 100,
            free: Math.round(free * 100) / 100,
            usage: Math.round(usage * 100) / 100
          };
        }
      } catch (execError) {
        console.error('Error executing wmic:', execError);
      }
      
      // Fallback ???? Windows
      return {
        total: 100,
        used: 50,
        free: 50,
        usage: 50
      };
    }
    
    // ???? Linux/Mac - ??????? ?? df
    try {
      const { stdout } = await execAsync('df -BG / | tail -1');
      const parts = stdout.trim().split(/\s+/);
      const total = parseFloat(parts[1]?.replace('G', '') || '100');
      const used = parseFloat(parts[2]?.replace('G', '') || '50');
      const free = parseFloat(parts[3]?.replace('G', '') || '50');
      const usage = (used / total) * 100;
      
      return {
        total: Math.round(total * 100) / 100,
        used: Math.round(used * 100) / 100,
        free: Math.round(free * 100) / 100,
        usage: Math.round(usage * 100) / 100
      };
    } catch (dfError) {
      console.error('Error executing df:', dfError);
    }
    
    // Fallback values
    return {
      total: 100,
      used: 50,
      free: 50,
      usage: 50
    };
  } catch (error) {
    console.error('Error getting disk usage:', error);
    // Fallback values
    return {
      total: 100,
      used: 50,
      free: 50,
      usage: 50
    };
  }
}

// ???? ???? ??? ???? Database
async function getDatabaseResponseTime(): Promise<{ responseTime: number; status: 'healthy' | 'slow' | 'error' }> {
  try {
    const startTime = Date.now();
    await prisma.$queryRaw`SELECT 1`;
    const responseTime = Date.now() - startTime;
    
    let status: 'healthy' | 'slow' | 'error' = 'healthy';
    if (responseTime > 1000) {
      status = 'slow';
    } else if (responseTime > 5000) {
      status = 'error';
    }
    
    return { responseTime, status };
  } catch (error) {
    console.error('Database health check error:', error);
    return { responseTime: -1, status: 'error' };
  }
}

// ???? ???? ??? Health Check API
async function getAPIHealth(): Promise<{ status: 'healthy' | 'warning' | 'error'; endpoints: Array<{ name: string; status: 'ok' | 'error'; responseTime: number }> }> {
  const endpoints = [
    { name: 'Database', url: '/api/admin/system/metrics' },
    { name: 'Auth', url: '/api/v1/admin/auth/login/check-email' },
  ];
  
  const results = await Promise.all(
    endpoints.map(async (endpoint) => {
      try {
        const startTime = Date.now();
        // ??? ???? - ??? ????? ????? endpoint ???? ????
        const responseTime = Date.now() - startTime;
        return {
          name: endpoint.name,
          status: 'ok' as const,
          responseTime
        };
      } catch (error) {
        return {
          name: endpoint.name,
          status: 'error' as const,
          responseTime: -1
        };
      }
    })
  );
  
  const hasError = results.some(r => r.status === 'error');
  const hasSlow = results.some(r => r.responseTime > 1000);
  
  let status: 'healthy' | 'warning' | 'error' = 'healthy';
  if (hasError) {
    status = 'error';
  } else if (hasSlow) {
    status = 'warning';
  }
  
  return { status, endpoints: results };
}

// ???? ???? ????? ?????? ? ?????????
function analyzeMetrics(
  cpu: { usage: number },
  ram: { usage: number; free: number },
  disk: { usage: number; free: number },
  db: { responseTime: number; status: string },
  api: { status: string }
): Array<{ type: 'warning' | 'error' | 'info'; message: string; suggestion: string }> {
  const issues: Array<{ type: 'warning' | 'error' | 'info'; message: string; suggestion: string }> = [];
  
  // ????? CPU
  if (cpu.usage > 90) {
    issues.push({
      type: 'error',
      message: `??????? CPU ????? ???? ???: ${cpu.usage}%`,
      suggestion: '????? ?????????? ?????? ?????????? ??? ?? ?????? ????? ????'
    });
  } else if (cpu.usage > 70) {
    issues.push({
      type: 'warning',
      message: `??????? CPU ???? ???: ${cpu.usage}%`,
      suggestion: '????? ?????????? ?? ??? ???? ? ?????????? ??????'
    });
  }
  
  // ????? RAM
  if (ram.usage > 90) {
    issues.push({
      type: 'error',
      message: `??????? RAM ????? ???? ???: ${ram.usage}% (${ram.free.toFixed(2)} GB ????)`,
      suggestion: '?????? RAM ???? ?? ?????????? ??????? ?? ????? ?? ??????'
    });
  } else if (ram.usage > 80) {
    issues.push({
      type: 'warning',
      message: `??????? RAM ???? ???: ${ram.usage}% (${ram.free.toFixed(2)} GB ????)`,
      suggestion: '????? ?????????? ?? ??? ???? ? ??????? ????? ??'
    });
  }
  
  // ????? Disk
  if (disk.usage > 90) {
    issues.push({
      type: 'error',
      message: `???? ???? ????? ?? ???: ${disk.usage}% ??????? ??? (${disk.free.toFixed(2)} GB ????)`,
      suggestion: '??????? ???????? ?????? ?????? ? ???????? ???? ?? ?????? ???? ????'
    });
  } else if (disk.usage > 80) {
    issues.push({
      type: 'warning',
      message: `???? ???? ?? ???: ${disk.usage}% ??????? ??? (${disk.free.toFixed(2)} GB ????)`,
      suggestion: '????? ? ??????? ???????? ???????? ? ??????? ?????'
    });
  }
  
  // ????? Database
  if (db.status === 'error' || db.responseTime > 5000) {
    issues.push({
      type: 'error',
      message: `???? ?? ????? ?? ???????: ???? ???? ${db.responseTime}ms`,
      suggestion: '????? ????? ???????? ?????????? ???????? ?? ?????? ????? ???????'
    });
  } else if (db.status === 'slow' || db.responseTime > 1000) {
    issues.push({
      type: 'warning',
      message: `???? ???? ??????? ??? ???: ${db.responseTime}ms`,
      suggestion: '?????????? ????????? ?????? ?????? ?? ????? ??? ???????'
    });
  }
  
  // ????? API
  if (api.status === 'error') {
    issues.push({
      type: 'error',
      message: '???? ?? API endpoints',
      suggestion: '????? ??????? ???? ? ??????? ?? ?? ????? ???? ???? endpoint???'
    });
  } else if (api.status === 'warning') {
    issues.push({
      type: 'warning',
      message: '???? ?? API endpoints ??? ?????',
      suggestion: '?????????? endpoint???? ??? ? ????? ?????? ????'
    });
  }
  
  return issues;
}

export async function GET() {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get("session")?.value;
    
    if (!token) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    
    const { role } = await verifyJWT(token);
    
    // ??? Admin ? Super Admin ????????? ???????? ?? ??????
    if (role !== 'Admin' && role !== 'Super Admin') {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }
    
    // ?????? ????????
    const [cpu, ram, disk, db, api] = await Promise.all([
      Promise.resolve(getCPUUsage()),
      Promise.resolve(getRAMUsage()),
      getDiskUsage(),
      getDatabaseResponseTime(),
      getAPIHealth()
    ]);
    
    // ????? ? ????? ??????
    const issues = analyzeMetrics(cpu, ram, disk, db, api);
    
    return NextResponse.json({
      timestamp: new Date().toISOString(),
      cpu,
      ram,
      disk,
      database: db,
      api,
      issues,
      system: {
        platform: process.platform,
        nodeVersion: process.version,
        uptime: Math.round(os.uptime() / 3600) // ????
      }
    });
  } catch (error: any) {
    console.error("Error fetching system metrics:", error);
    return NextResponse.json(
      { error: error.message || "Internal Server Error" },
      { status: 500 }
    );
  }
}
